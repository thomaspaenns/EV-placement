# -*- coding: utf-8 -*-
"""Model_Full_Dataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16VvsRFYhEx05wmmmxsO81Mk57qNbv440
"""

!pip install pandas
import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd

!pip install gurobipy>=9.5.1
import gurobipy as gp
from gurobipy import GRB as GRB
import numpy as np

#Create Graph from CSVs
df = pd.read_csv('401_Data.csv')
df['dist_to_next'] = (df['Sec Len'] + df['Sec Len'].shift(-1)) / 2
df = df.astype({'AADT':int, 'LHRS':int})
df['demand'] = df['AADT']*((1-(df['Truck %']/100))*0.033*0.02072)
G = nx.Graph()
for index, row in df.iterrows():
  next_index = index + 1
  if next_index < len(df):
    current_segment = row['LHRS']
    next_segment = df.loc[next_index, 'LHRS']
    G.add_edge(int(current_segment), int(next_segment), length=float(row['dist_to_next']))
nx.draw_networkx(G, node_size=50, font_size=6, pos=nx.drawing.spiral_layout(G))

#Create Sets & Params
I = df['LHRS']
J = I
C = [1,2,3]
Cap = {1:48,2:96,3:192} #Cars charged per hour (2 per port)
d = dict(zip(I, df['demand']))
f = {
    1:dict(zip(I, df['cost 1'])),
    2:dict(zip(I, df['cost 2'])),
    3:dict(zip(I, df['cost 3']))
}
R = 40
Budget = 300000

#Compute shortest path lengths
paths = {}
for lhrs_num in df['LHRS']:
  paths.update({lhrs_num: nx.shortest_path_length(G, source=lhrs_num, weight='length')})
l = paths

# Create environment with WLS license
e = gp.Env(empty=True)
e.setParam('WLSACCESSID', '7e2d40a7-904b-4d00-b37c-6993c3716fb6')
e.setParam('WLSSECRET', '731bbd0f-37ee-4c88-9d28-c4f67b9c7952')
e.setParam('LICENSEID', 2396892)
e.start() 

# Create the model within the Gurobi environment
model = gp.Model(env=e)

#Model Instance
#model = gp.Model(name="ChargingLocationProblem", )
#Decision Variables
x = model.addVars(I, C, vtype=GRB.BINARY, name="x")
y = model.addVars(I, J, vtype=GRB.BINARY, name="y")

# constraints
[model.addConstr(sum(x[i, c] for c in C) <= 1) for i in I]
[model.addConstr(
    sum(d[j]*y[i, j] for j in J) <= sum(Cap[c]*x[i,c] for c in C)
) for i in I]
[model.addConstr(l[i][j]*y[i,j] <= R) for i in I for j in J]
model.addConstr(sum(f[c][i]*x[i,c] for i in I for c in C) <= Budget)

model.setObjective(sum(d[j]*y[i,j] for i in I for j in J), sense=GRB.MAXIMIZE)

model.optimize()
model.printAttr('x')